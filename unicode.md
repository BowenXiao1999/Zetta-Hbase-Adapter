# 字符编码概述

最近用到了etcd的一个kv.proto生成的mvccpb.KeyValue结构体，里面的Value是[]byte类型的，可是用string()始终不能完美地打印在控制台上，因此顺便总结了一下字符编解码相关知识点。

## ASCII/Unicode 编码
ASCII是一开始美国人自己玩电脑的时候用的，英文又比较少，所以ASCII整体设计特别简单，一个字节没用完就囊括了所有要用的字符。但是后来欧洲人和中国人也想玩计算机，这个ASCII实在不够用，于是又自己捣鼓起了ISO，GBK。因为欧洲人和中国人玩的时候，也要兼容ASCII（毕竟那些字符自己也用得上），所以前127号没变。但是128-256号的变化就大了，尤其是欧洲国家，同一个位置代表不同的字符，严重阻碍了交流。

后来互联网出现，统一字符集是大势所趋，于是有人牵头弄了个Unicode，势必要囊括所有你能想得到的字符。Unicode提供的是一个映射表，字符-》Unicode Point。比如U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。这个相当于一个统一规范，大家都别争了，统一按这个标准来。


## Utf-8
但是这个U+开头的代码，并没有实际规定计算机的存储格式。换句话说，Unicode提供的是抽象编码，不是计算机实际存储的格式。于是Utf-8就出现了。这是一种变字节（1-4）的编码格式，可以根据Unicode编码的位置，调整分配的字节数量。比如1，你不用分配4个字节，只用1个就够了。这种比较人性化，减少了文本的体积。

Utf-8 计算的过程：

1. 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

2. 对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

Unicode符号范围     |        UTF-8编码方式
(十六进制)        |              （二进制）da
----------------------|---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

实际例子：d
严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。


## Go的字符串表示
计算机语言中，字符串一般都是""或者''来表示。但是它们的底层存储却各不相同。Go底层默认存储字符串的格式是[]byte字符数组，而byte又是uint8的别名。
举个例子，那个我始终打印不出来的[]byte，底层数组是这个样子。

(Printf占位符为%v)
```
[]byte{255,0,0,0,20,109,97,115,116,101,114,58,49,54,48,48,48,238,184,44 ,12 ,55 ,147 ,137 ,251 ,80 ,66 ,85 ,70 ,10 ,24 ,10 ,12 ,49 ,48 ,46 ,57 ,49 ,46 ,52 ,52 ,46 ,49 ,50 ,50 ,16 ,148 ,125 ,24,211,141,170,170,182,46,16,0,24,3}
```

你也可以用\x来表示(调整Printf占位符为%#v)
```
[]byte{0xff, 0x0, 0x0, 0x0, 0x14, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x3a, 0x31, 0x36, 0x30, 0x30, 0x30, 0x1d, 0xfa, 0x16, 0x31, 0x5b, 0x7c, 0x3f, 0x4e, 0x50, 0x42, 0x55, 0x46, 0xa, 0x18, 0xa, 0xc, 0x31, 0x30, 0x2e, 0x39, 0x31, 0x2e, 0x34, 0x34, 0x2e, 0x31, 0x32, 0x32, 0x10, 0x94, 0x7d, 0x18, 0xb6, 0xcb, 0xa5, 0xb1, 0xb6, 0x2e, 0x10, 0x0, 0x18, 0x3}
```

那么Go尝试把它打印成一个String的时候，就会按照之前说utf8的规则来解释这些字符（Go默认Utf8）。根据每个字符的二进制表示，来看是读一个字节还是2个，3个甚至4个字节，从而把这些字符翻译成对应的字符串。但是不幸的是，我依然没能破译，接下来可能要去源码里去读一下是怎么编码的。
